#include "memdef.h"

// declare all possible external routines, whether we use them or not.:
extern "C" {
  void __libc_init_array(void); // The entry point for the C++ library startup
  void SystemInit(void); // __USE_CMSIS __USE_LPCOPEN
  int main(void); // entry point
  void generateHardReset(void); // doesn't return! supplied by nvic.cpp as that is where reset hardware happens to reside.

#if startupComplexity>1
/*****************************************************************************
 *  The following symbols are constructs generated by the linker, indicating
 *  the location of various points in the "Global Section Table". This table is
 *  created by the linker via the Code Red managed linker script mechanism. It
 *  contains the load address, execution address and length of each RW data
 *  section and the execution and length of each BSS (zero initialized) section.
 * It happens that for the simpler processors the tables have only one entry.
 */
  struct InitializedRam {
    unsigned int *rom;
    unsigned int *ram;
    unsigned int length;
  };

  InitializedRam *__data_section_table;
  InitializedRam *__data_section_table_end;

  struct ZeroedRam {
    unsigned int *ram;
    unsigned int length;
  };

  ZeroedRam *__bss_section_table;
  ZeroedRam *__bss_section_table_end;
  #else
    #define LinkerMagic(ref)   extern "C" unsigned int ref
    LinkerMagic (__data_target__[]);
    LinkerMagic (__data_length__);
    LinkerMagic (__data_source__[]);
    LinkerMagic(__zero_start__[]);
    LinkerMagic(__zero_length__);

#endif
}


// instead of tracking #defined symbols just dummy up the optional routines:
__attribute__ ((weak,naked)) void SystemInit(void){
  // nothing to do
}

__attribute__ ((weak,naked)) void __libc_init_array(void){
  // must not be any C++ static construction or other libc startup.
  asm(" bx lr");
}

/** NB: this startup presumes 32 bit aligned, 32bit padded structures, but linker gives byte addresses and counts */
void data_init(const unsigned int *rom, unsigned int *ram, unsigned int len){
  len /= sizeof(unsigned int); // convert byte count to u32 count.
  while(len-- > 0) {
    *ram++ = *rom++;
  }
}

/** NB: this startup presumes 32 bit aligned, 32bit padded bss, but linker gives byte addresses and counts.
 *  Does anyone remember what BSS originally meant? Nowadays it is 'zeroed static variables' */
void bss_init(unsigned int *ram, unsigned int len){
  len /= sizeof(unsigned int); // convert byte count to u32 count.
  while(len-- > 0) {
    *ram++ = 0;
  }
}

/*****************************************************************************
 * Reset entry point. Not actually an isr as it is jumped to, not called nor vectored to.
 * Sets up a simple runtime environment and initializes the C/C++ library.
 */
extern "C" void cstartup(void);
void cstartup(void){
#if startupComplexity>1
  // initialize static variables
  for(InitializedRam *rammer = __data_section_table; rammer < __data_section_table_end; ++rammer) {
    data_init(rammer->rom, rammer->ram, rammer->length);
  }
  // Zero other static variables.
  for(ZeroedRam *zeroer = __bss_section_table; zeroer < __bss_section_table_end; ++zeroer) {
    bss_init(zeroer->ram, zeroer->length);
  }
  #else
  // initialize static variables
    data_init(__data_source__, __data_target__, __data_length__);
  // Zero other static variables.
    bss_init(__zero_start__, __zero_length__);
  #endif
  // a hook:
  SystemInit(); // stuff that C++ construction might need, like turning on hardware modules (e.g. LPC::GPIO::Init())
  //todo: run constructors here
  // a hook
  __libc_init_array(); // C++ library initialization (? constructors for static objects?)
  //todo: run init here, unless that is what libc_init_array exists to do.

  // todo: if main is in ram then remap vectors to ram:
  main();
  // todo: theoretically could find and execute destructors for static objects.
  generateHardReset(); // auto restart on problems, design your system to tolerate spontaneous power cycles on fatal firmware error
} // start

// stack pointer: set to end of ram so as to have the maximum available.
#if 1
//back to using nvic version, linker didn't do this.
unsigned stacktop __attribute__((section(".vectors.0"))) = (SRAM_BASE + SRAM_K * 1024);
void (*resetVector)(void) __attribute__((section(".vectors.1"))) = cstartup;
#endif
// rest of table is in nvic.cpp, trusting linker script to order files correctly for now. Need to extend the section names for safety.
// end custom pre-main startups

extern "C" void generateHardReset(){while(1);}//stub