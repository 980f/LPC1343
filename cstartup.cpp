/*****************************************************************************
 * LPC13xx Microcontroller Startup code
 * heavily hacked by alh from LPCXpresso IDE 2014/04.
 *
 * NXP Version : 140113
 *
 * Copyright(C) NXP Semiconductors, 2013-2014
 * All rights reserved.
 *
 * Software that is described herein is for illustrative purposes only which provides customers with programming information regarding the
 * LPC products.  This software is supplied "AS IS" without any warranties of
 * any kind, and NXP Semiconductors and its licensor disclaim any and
 * all warranties, express or implied, including all implied warranties of
 * merchantability, fitness for a particular purpose and non-infringement of
 * intellectual property rights.  NXP Semiconductors assumes no responsibility
 * or liability for the use of the software, conveys no license or rights under any
 * patent, copyright, mask work right, or any other intellectual property rights in
 * or to any products. NXP Semiconductors reserves the right to make changes
 * in the software without notification. NXP Semiconductors also makes no
 * representation or warranty that such application will be suitable for the
 * specified use without further testing or modification.
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation is hereby granted, under NXP Semiconductors' and its
 * licensor's relevant copyrights in the software, without fee, provided that it
 * is used in conjunction with NXP Semiconductors microcontrollers.  This
 * copyright, permission, and disclaimer notice must appear in all copies of
 * this code.
 */

// declare all possible external routines, whether we use them or not.:
extern "C" {
  void __libc_init_array(void); // The entry point for the C++ library startup
  void SystemInit(void); // __USE_CMSIS __USE_LPCOPEN
  int main(void); // entry point
  void generateHardReset(void); // doesn't return!

/*****************************************************************************
 *  The following symbols are constructs generated by the linker, indicating
 *  the location of various points in the "Global Section Table". This table is
 *  created by the linker via the Code Red managed linker script mechanism. It
 *  contains the load address, execution address and length of each RW data
 *  section and the execution and length of each BSS (zero initialized) section.
 */
  struct InitializedRam {
    unsigned int *rom;
    unsigned int *ram;
    unsigned int length;
  };

  InitializedRam *__data_section_table;
  InitializedRam *__data_section_table_end;

  struct ZeroedRam {
    unsigned int *ram;
    unsigned int length;
  };

  ZeroedRam *__bss_section_table;
  ZeroedRam *__bss_section_table_end;
}


// instead of tracking #defined symbols just dummy up the optional routines:
__attribute__ ((section(".after_vectors")))
__attribute__ ((weak)) void SystemInit(void){
  // nothing to do
}
__attribute__ ((section(".after_vectors")))
__attribute__ ((weak)) void __libc_init_array(void){
  // must not be any C++ static construction or other libc startup.
}

/** startup only copies 32 bit aligned, 32bit padded structures, but linker gives byte addresses and counts */
__attribute__ ((section(".after_vectors")))
void data_init(unsigned int *rom, unsigned int *ram, unsigned int len){
  len /= sizeof(unsigned int); // convert byte count to u32 count.
  while(len-- > 0) {
    *ram++ = *rom++;
  }
}

/** startup only copies 32 bit aligned, 32bit padded structures, but linker gives byte addresses and counts.
 *  Does anyone remember what BSS originally meant? Nowadays it is 'zeroed static variables' */
__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int *ram, unsigned int len){
  len /= sizeof(unsigned int); // convert byte count to u32 count.
  while(len-- > 0) {
    *ram++ = 0;
  }
}

/*****************************************************************************
 * Reset entry point. Not actually an isr as it is jumped to, not called nor vectored to.
 * Sets up a simple runtime environment and initializes the C/C++ library.
 */
__attribute__ ((section(".after_vectors")))
void cstartup(void){
  //initialize static variables
  for(InitializedRam *rammer = __data_section_table; rammer < __data_section_table_end; ++rammer) {
    data_init(rammer->rom, rammer->ram, rammer->length);
  }
  // Zero other static variables.
  for(ZeroedRam *zeroer = __bss_section_table; zeroer < __bss_section_table_end; ++zeroer) {
    bss_init(zeroer->ram, zeroer->length);
  }
  //a hook:
  SystemInit(); // stuff that C++ construction might need, like turning on hardware modules (e.g. LPC::GPIO::Init())
  //a hook
  __libc_init_array(); // C++ library initialization (? constructors for static objects?)
  main();
  // todo: theoretically could find and execute destructors for static objects.
  generateHardReset(); // this choice is based upon the system tolerating spontaneous power cycles.
} // start

// default for applications that predated this symbol, stm32F103CB's:
#ifndef SRAM_K
#define SRAM_K 20
#warning setting default amount of ram
#endif
// default for stm32:
#ifndef SRAM_BASE
#define SRAM_BASE 0x20000000
#warning setting stm32F10x ram base address.
#endif

// stack pointer: set to end of ram so as to have the maximum available.
unsigned stacktop __attribute__((section(".isr_vector"))) = (SRAM_BASE + SRAM_K * 1024);
void (*resetVector)(void) __attribute__((section(".isr_vector"))) = cstartup;

// end custom pre-main startups
