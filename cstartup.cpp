/*****************************************************************************
 * LPC13xx Microcontroller Startup code
 * heavily hacked by alh from LPCXpresso IDE 2014/04.
 *
 * NXP Version : 140113
 *
 * Copyright(C) NXP Semiconductors, 2013-2014
 * All rights reserved.
 *
 * Software that is described herein is for illustrative purposes only which provides customers with programming information regarding the
 * LPC products.  This software is supplied "AS IS" without any warranties of
 * any kind, and NXP Semiconductors and its licensor disclaim any and
 * all warranties, express or implied, including all implied warranties of
 * merchantability, fitness for a particular purpose and non-infringement of
 * intellectual property rights.  NXP Semiconductors assumes no responsibility
 * or liability for the use of the software, conveys no license or rights under any
 * patent, copyright, mask work right, or any other intellectual property rights in
 * or to any products. NXP Semiconductors reserves the right to make changes
 * in the software without notification. NXP Semiconductors also makes no
 * representation or warranty that such application will be suitable for the
 * specified use without further testing or modification.
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation is hereby granted, under NXP Semiconductors' and its
 * licensor's relevant copyrights in the software, without fee, provided that it
 * is used in conjunction with NXP Semiconductors microcontrollers.  This
 * copyright, permission, and disclaimer notice must appear in all copies of
 * this code.
 */

// declare all possible external routines, whether we use them or not.:
extern "C" {
  void __libc_init_array(void); // The entry point for the C++ library startup
  void SystemInit(void); // __USE_CMSIS __USE_LPCOPEN
  int main(void); // entry point
  void generateHardReset(void); // doesn't return!

/*****************************************************************************
 *  The following symbols are constructs generated by the linker, indicating
 *  the location of various points in the "Global Section Table". This table is
 *  created by the linker via the Code Red managed linker script mechanism. It
 *  contains the load address, execution address and length of each RW data
 *  section and the execution and length of each BSS (zero initialized) section.
 */

  unsigned int __data_section_table;
  unsigned int __data_section_table_end;
  unsigned int __bss_section_table;
  unsigned int __bss_section_table_end;
}

__attribute__ ((section(".after_vectors")))
void data_init(unsigned int *rom, unsigned int *ram, unsigned int len){
  len /= 4; // convert byte count to u32 count.
  while(len-- > 0) {
    *ram++ = *rom++;
  }
}

__attribute__ ((section(".after_vectors")))
void bss_init(unsigned int *ram, unsigned int len){
  len /= 4; // convert byte count to u32 count.
  while(len-- > 0) {
    *ram++ = 0;
  }
}

/*****************************************************************************
 * Reset entry point. Not actually an isr as it is jumped to, not called.
 * Sets up a simple runtime environment and initializes the C/C++ library.
 */

__attribute__ ((section(".after_vectors")))
void start(void){
  // Load base address of Global Section Table
  unsigned int *SectionTableAddr = &__data_section_table;

  // Copy the data sections from flash to SRAM.
  while(SectionTableAddr < &__data_section_table_end) {
    // can't do these in function parameter list due to no guarantee by compiler of argument processing order.
    unsigned int *LoadAddr = reinterpret_cast<unsigned int *>(*SectionTableAddr++);
    unsigned int *ExeAddr = reinterpret_cast<unsigned int *>(*SectionTableAddr++);
    unsigned int SectionLen = *SectionTableAddr++;
    data_init(LoadAddr, ExeAddr, SectionLen);
  }
  // At this point we trust that, SectionTableAddr = &__bss_section_table;
  // Zero fill the bss segment
  while(SectionTableAddr < &__bss_section_table_end) {
    unsigned int *ExeAddr = reinterpret_cast<unsigned int *>(*SectionTableAddr++);
    unsigned int SectionLen = *SectionTableAddr++;
    bss_init(ExeAddr, SectionLen);
  }
  SystemInit(); // stuff that C++ construction might need, like turning on hardware modules (GPIO::Init())
  __libc_init_array(); // C++ library initialisation (? constructors for static objects?)
  main();
  // todo: theoretically could find and execute destructors for static objects.
  generateHardReset(); // this choice is based upon the system tolerating spontanenous power cycles.
} // start


// instead of tracking #defined symbols just dummy up the optional routines:
__attribute__ ((section(".after_vectors")))
__attribute__ ((weak)) void SystemInit(void){
  // nothing to do
}
__attribute__ ((section(".after_vectors")))
__attribute__ ((weak)) void __libc_init_array(void){
  // must not be any C++ static construction
}
// end custom pre-main startups
